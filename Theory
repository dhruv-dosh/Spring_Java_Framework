### 1. Inversion of Control (IoC)
* **Definition:** IoC is a design principle where the flow of control of an application is inverted. Instead of the application code being responsible for creating and managing its dependencies and their lifecycle, that responsibility is **delegated to a framework or a container** (like the Spring IoC container).
* **Analogy:** It’s often referred to as the "Hollywood Principle": "**Don't call us, we'll call you.**" Your custom code focuses purely on business logic, and the framework calls your code (e.g., to inject dependencies) when needed.
* **Benefit:** Promotes loose coupling and enhances modularity and testability.

### 2. IoC Container (e.g., Spring Container)
* **Definition:** The IoC Container is the core component or engine of a framework (like Spring) that is responsible for **instantiating, configuring, and assembling** objects (known as **Beans**) and managing their entire lifecycle.
* **Role:** It implements the Inversion of Control principle, primarily through **Dependency Injection**. It reads configuration metadata (XML or annotations) to figure out which beans to create, which dependencies they need, and how to inject them.

### 3. Dependency Injection (DI)
* **Definition:** Dependency Injection is a design pattern used to implement IoC. It's the process where an object receives its required dependencies from an **external source** (the IoC container) rather than creating them itself.
* **Mechanism:** The container *injects* the required objects into the dependent object at runtime.
* **Benefit:** Decreases tight coupling between components, making the code more flexible, testable, and maintainable.

### 4. Types of Dependency Injection
The container can inject dependencies in a few ways:

* **Constructor Injection:** The container supplies the dependencies through a class's constructor arguments. This is generally preferred as it ensures that the object is created in a valid state with all required dependencies initialized (i.e., it makes dependencies mandatory).
* **Setter Injection (or Property Injection):** The container supplies the dependencies by calling the public setter methods of the class after the object has been created using a no-argument constructor. This is suitable for optional dependencies.
* **Field Injection:** The container injects dependencies directly into private fields using reflection. While convenient due to less boilerplate code, it's generally discouraged in favor of constructor injection as it hides dependencies and makes the class harder to test without the container.

### 5. Difference between Spring and Spring Boot

| Feature | Spring Framework | Spring Boot |
| :--- | :--- | :--- |
| **Nature** | A **comprehensive framework** for building Java enterprise applications. | An **extension/convention-over-configuration layer** built on top of the Spring Framework. |
| **Configuration** | Requires significant and often complex configuration (XML or extensive Java config) for things like DataSource, View Resolvers, etc. | **Minimal configuration** due to **Auto-Configuration** and "sensible defaults." |
| **Server** | Requires an external application server (e.g., Tomcat, Jetty) for deployment (e.g., a WAR file). | Includes an **embedded server** (Tomcat, Jetty, or Undertow) by default, allowing you to run it as a standalone JAR. |
| **Dependencies** | Requires manual declaration and version management for all dependencies. | Uses **Starter POMs** (e.g., `spring-boot-starter-web`) to group related dependencies and manage versions automatically. |
| **Goal** | To provide a robust, flexible platform for large-scale enterprise applications. | To enable the **rapid creation of production-ready, stand-alone Spring applications** with minimal effort. |

### 6. MVC Structure (Model-View-Controller)
* **Definition:** MVC is a software architectural pattern that separates an application into three interconnected parts to isolate internal representations of information from the user interface presentation.
* **Components:**
    * **Model:** Manages the application's data, business logic, and state. It is independent of the user interface.
    * **View:** Renders the presentation of the data in a particular format (e.g., HTML, JSON) to the user.
    * **Controller:** Handles user input, processes requests, interacts with the Model to update data, and selects the appropriate View to render the response.
* **Benefit:** Separation of Concerns, which improves code organization, reusability, and maintainability.

### 7. ORM (Object-Relational Mapping)
* **Definition:** ORM is a programming technique that provides a layer of abstraction to **map a database's relational structure (tables, columns) to an application's object-oriented structure (classes, fields).**
* **Role:** It allows developers to interact with the database using their programming language's objects and methods instead of writing raw SQL queries. The ORM tool handles the translation of object operations into SQL statements and vice-versa.
* **Example:** Hibernate and EclipseLink are popular ORM frameworks in Java.

### 8. Spring Data JPA
* **Definition:** Spring Data JPA is a sub-project of the Spring Framework that **significantly simplifies the implementation of data access layers** for applications using the Java Persistence API (JPA).
* **Key Feature:** It provides an abstraction called a **Repository** interface (e.g., `JpaRepository`). By simply defining a repository interface and extending a Spring Data interface, the framework automatically generates and implements common CRUD (Create, Read, Update, Delete) and custom query methods based on the method name convention (e.g., `findByLastNameAndFirstName(String lastName, String firstName)`).
* **Benefit:** Reduces boilerplate code and increases developer productivity.

### 9. JPQL (Java Persistence Query Language)
* **Definition:** JPQL is the **platform-independent object-oriented query language** defined as part of the Java Persistence API (JPA) specification.
* **Key Characteristic:** Unlike SQL, which queries database tables and columns, **JPQL queries entities and their fields**. It uses the object model of the application.
* **Usage:** It is used within JPA/Hibernate to perform CRUD operations where the standard repository methods are insufficient.

### 10. Lombok
* **Definition:** Project Lombok is a Java library that **automatically plugs into the build process to generate boilerplate code** for Java classes.
* **Mechanism:** It uses annotations (like `@Getter`, `@Setter`, `@ToString`, `@NoArgsConstructor`, `@AllArgsConstructor`, and `@Data`) to generate the corresponding methods at compile time.
* **Benefit:** Significantly reduces the amount of repetitive, verbose code, making Java classes more concise and readable.

### 11. Spring Security and JWT Authentication
#### Spring Security
* **Definition:** Spring Security is a **powerful and highly customizable authentication and access control (authorization) framework** for securing Java applications, especially those built with Spring.
* **Mechanism:** Its primary mechanism is a **chain of filters** that intercept incoming HTTP requests to perform security checks (e.g., checking credentials, validating tokens, authorizing resource access) before the request reaches the Controller.

#### JWT Authentication (with Spring Security)
* **JWT (JSON Web Token):** A compact, URL-safe means of representing claims (like user identity) to be transferred between two parties. It consists of three parts: **Header, Payload, and Signature**. It's primarily used for **stateless authentication**.
* **Authentication Flow:**
    1.  The client sends credentials (username/password) to the server.
    2.  The server (using Spring Security) authenticates the user and generates a signed JWT.
    3.  The server returns the JWT to the client.
    4.  For subsequent requests, the client sends the JWT (typically in the **`Authorization` header** as a Bearer token).
    5.  A custom **JWT Filter** in the Spring Security chain intercepts the request, validates the JWT's signature and expiration, extracts the user's details, and sets the authentication context for the request to be authorized.



### Authentication vs. Authorization

| Feature | Authentication (AuthN) | Authorization (AuthZ) |
| :--- | :--- | :--- |
| **Core Question** | **"Who are you?"** (Verifying Identity) | **"What are you allowed to do?"** (Granting Access) |
| **Definition** | The process of **verifying the identity** of a user, system, or application (e.g., confirming you are who you claim to be). | The process of **determining what resources or actions** a successfully authenticated user is permitted to access. |
| **Mechanism** | Based on **credentials** (passwords, biometrics, security tokens, OTP, etc.). | Based on **permissions, roles** (Role-Based Access Control/RBAC), or policies assigned to the user's identity. |
| **Sequence** | **Always comes first.** You must prove your identity before the system can check your permissions. | **Always comes after** successful authentication. |
| **Analogy** | **Checking your ID** at the entrance of a building. | **Checking your key card** to see which floors and rooms you can enter. |
| **Outcome** | Successful authentication typically results in a login session or an **ID Token** (like a JWT). | Successful authorization grants an **Access Token** or permission to use a specific resource (like a specific API endpoint or a file). |

***

### Simple Summary for an Interview

"Authentication is the process of confirming a user's identity, often through a username and password—it's **proving who you are**.

Authorization comes after; it's the process of defining and enforcing what an authenticated user **is allowed to do or access** based on their assigned roles or privileges. For example, an 'Admin' is authorized to delete a record, but a 'Guest' is only authorized to read it."




It is common for interviewers to ask for answers to the previous questions in a structured, concise format. Here are the interview-ready answers for the most critical Spring concepts you requested.

I. Spring Core (IoC and DI)
1. What are the core features of the Spring Framework?
"The Spring Framework is primarily built around two core concepts: Inversion of Control (IoC) and Aspect-Oriented Programming (AOP).

IoC Container/DI: The container manages the lifecycle of Java objects (Beans) and injects their dependencies, promoting loose coupling.

AOP: It allows modularizing cross-cutting concerns like logging, security, and transaction management, keeping business logic clean.

Data Access: It provides easy integration and abstraction layers for persistence technologies like JDBC, JPA, and Hibernate.

Transaction Management: Offers a consistent, declarative approach to managing transactions across different environments."

2. Explain the different types of Dependency Injection. Which is preferred and why?
"There are three main types of Dependency Injection:

Constructor Injection: Dependencies are provided via a class's constructor.

Setter Injection: Dependencies are provided via public setter methods.

Field Injection: Dependencies are injected directly into fields using reflection.

Constructor Injection is strongly preferred because:

It ensures the object is created in a valid state with all mandatory dependencies present.

It easily allows for creating immutable objects by using final fields, improving thread safety and reliability."

3. What are the different Bean Scopes in Spring? Are Spring Singleton beans thread-safe?
"The primary bean scopes are:

Singleton (Default): Only one instance of the bean is created per Spring IoC container.

Prototype: A new instance is created every time the bean is requested.

Request, Session, GlobalSession: Used specifically in web applications, creating an instance per HTTP request, user session, etc.

Regarding Thread Safety:
Spring's default Singleton scope does NOT guarantee thread safety. Thread safety depends entirely on how the developer implements the bean. Since a single instance is shared across all concurrent threads, if that bean maintains a mutable internal state (instance variables), it will lead to race conditions. Therefore, Singleton beans should be designed to be stateless for the application to be thread-safe."




4. What is the difference between @Component, @Service, @Repository, and @Controller?
"All four are Spring Stereotype annotations that act as specializations of the generic @Component. They all signal to the Spring Container to create a bean during component scanning, but they have distinct semantic roles and sometimes add technical functionality:

Annotation	Layer/Role	Key Technical Feature
@Controller	Presentation Layer	Handles incoming HTTP requests in Spring MVC.
@Service	Business/Service Layer	Holds the core business logic and orchestrates transactions. No technical distinction, purely semantic.
@Repository	Persistence/DAO Layer	Handles database operations.
@Component	Generic	Used for any general-purpose utility or helper class that doesn't fit into the other three roles."

Export to Sheets
II. Spring Boot
5. What does the @SpringBootApplication annotation do internally?
"The @SpringBootApplication annotation is a convenience annotation that is equivalent to combining three other annotations:

@Configuration: Tags the class as a source of bean definitions for the application context.

@EnableAutoConfiguration: This is the key feature. It tells Spring Boot to automatically configure beans based on the JAR dependencies present on the classpath. For instance, if H2 is present, it auto-configures a data source.

@ComponentScan: This tells Spring to look for other components, configurations, and services in the current package and its sub-packages, and register them as beans."

6. What is Auto-Configuration and Starter Dependencies?
Auto-Configuration: "This is Spring Boot's 'Convention over Configuration' principle in action. It automatically configures Spring beans and settings based on what libraries it finds on the classpath. It dramatically reduces the need for manual configuration. For example, if you add the spring-boot-starter-web dependency, Spring Boot automatically configures Tomcat and DispatcherServlet."




Starter Dependencies (Starter POMs): "These are convenient dependency descriptors you can include in your build file. They pull in all the necessary common dependencies and transitively manage their version compatibility. For example, spring-boot-starter-data-jpa pulls in JPA, Hibernate, and the necessary Spring dependencies, all with compatible versions."


III. Spring Data JPA
7. How does Spring Data JPA simplify the data access layer?
"Spring Data JPA simplifies data access by eliminating almost all the boilerplate code required for implementing repositories. Instead of writing concrete classes for CRUD operations, you just define a Repository interface (e.g., extending JpaRepository). The framework automatically provides:

CRUD Functionality: Methods like save(), findById(), and delete().

Query Generation: Custom queries are automatically generated simply by defining methods with names following a specific convention, such as findByLastNameAndFirstName(String lastName, String firstName)."

8. What is JPQL, and how is it different from native SQL?
"JPQL (Java Persistence Query Language) is the object-oriented query language defined by the JPA specification.

Object-Oriented: JPQL queries are written against the application's Entity objects and their fields, not against the physical database tables and columns.

Portability: This abstraction makes JPQL queries database-agnostic. The underlying JPA provider (like Hibernate) translates the JPQL into the dialect of the target database (e.g., MySQL or PostgreSQL)."

IV. Spring Security and JWT
9. How do you implement JWT Authentication with Spring Security?

"JWT authentication provides a stateless mechanism, which is ideal for REST APIs and microservices. The process involves custom integration with the Spring Security filter chain:

Login/Token Generation: Upon successful authentication (e.g., username/password validation), the server generates a JWT and returns it to the client.

Subsequent Requests: The client sends the JWT in the Authorization header (as a Bearer token) for every protected request.

Custom Filter (JWT Filter): A custom filter is placed early in the Spring Security filter chain. This filter intercepts the request, validates the JWT's signature and expiration, extracts the user details from the token's payload, and manually sets the Authentication object in the SecurityContextHolder.

Authorization: Once the user is authenticated via the token, Spring Security's authorization mechanisms can proceed to check if the user has permission to access the requested resource."
